//! Test that expand is called on a GRootNode during build.
//!
//! This module tests that the build system correctly calls [`GRootNode::expand`]
//! on root nodes, allowing them to dynamically generate additional nodes and
//! edges in the build graph.
//!
//! # Test Coverage
//!
//! - [`test_grootnode_expand_called_during_make`]: Verifies that when `g.make()`
//!   is called, the `expand` method on `GRootNode` is invoked and the generated
//!   nodes are added to the graph.

mod common;

use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicBool, Ordering};
use tempdir::TempDir;
use yamake::model::{Edge, ExpandResult, G, GNode, GRootNode};

/// A flag to track whether expand was called.
static EXPAND_WAS_CALLED: AtomicBool = AtomicBool::new(false);

/// A root node that generates additional nodes and edges when expanded.
///
/// This struct implements [`GRootNode`] with a custom [`expand`](GRootNode::expand)
/// method that sets a flag when called and returns two [`GeneratedNode`]s.
pub struct ExpandingRootNode {
    /// The path associated with this root node.
    pub name: String,
}

impl ExpandingRootNode {
    /// Creates a new `ExpandingRootNode` with the given name.
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
        }
    }
}

/// A simple node that can be generated by the expand operation.
pub struct GeneratedNode {
    /// The path associated with this generated node.
    pub name: String,
}

impl GeneratedNode {
    /// Creates a new `GeneratedNode` with the given name.
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
        }
    }
}

impl GNode for GeneratedNode {
    fn tag(&self) -> String {
        "GeneratedNode".to_string()
    }

    fn pathbuf(&self) -> PathBuf {
        PathBuf::from(&self.name)
    }

    fn build(&self, _sandbox: &Path, _predecessors: &[&(dyn GNode + Send + Sync)]) -> bool {
        true
    }
}

impl GRootNode for ExpandingRootNode {
    fn tag(&self) -> String {
        "ExpandingRootNode".to_string()
    }

    fn pathbuf(&self) -> PathBuf {
        PathBuf::from(&self.name)
    }

    fn expand(
        &self,
        _sandbox: &Path,
        _predecessors: &[&(dyn GNode + Send + Sync)],
    ) -> ExpandResult {
        // Set the flag to indicate expand was called
        EXPAND_WAS_CALLED.store(true, Ordering::SeqCst);

        // Generate two nodes when expanded
        let node1 = GeneratedNode::new("generated/node1.txt");
        let node2 = GeneratedNode::new("generated/node2.txt");

        let nodes: Vec<Box<dyn GNode + Send + Sync>> = vec![Box::new(node1), Box::new(node2)];

        // Create an edge from this root to the first generated node
        let edges: Vec<Edge> = vec![Edge {
            nfrom: Box::new(ExpandingRootNode::new(&self.name)),
            nto: Box::new(GeneratedNode::new("generated/node1.txt")),
        }];

        (nodes, edges)
    }
}

/// Tests that `GRootNode::expand` is called during `g.make()`.
///
/// This test verifies that:
/// - When a `GRootNode` is added to the graph and `make()` is called,
///   the `expand` method is invoked on the root node.
/// - The nodes generated by `expand` are added to the graph.
#[test]
fn test_grootnode_expand_called_during_make() {
    // Reset the flag before the test
    EXPAND_WAS_CALLED.store(false, Ordering::SeqCst);

    let srcdir = TempDir::new("yamake_test_grootnode_srcdir").unwrap();
    let srcdir_path = srcdir.path().to_path_buf();
    let sandbox = TempDir::new("yamake_test_grootnode_expand_make").unwrap();
    let sandbox_path = sandbox.path().to_path_buf();

    // Create the source file that will be mounted
    std::fs::write(srcdir_path.join("root.txt"), "test content").unwrap();

    let mut g = G::new(srcdir_path, sandbox_path);

    // Add the expanding root node to the graph
    let _root_idx = g.add_root_node(ExpandingRootNode::new("root.txt")).unwrap();

    // Initial node count (just the root node)
    let initial_node_count = g.g.node_count();
    assert_eq!(initial_node_count, 1, "Should have 1 node before make");

    // Build the graph - this should call expand on the root node
    let result = g.make();
    assert!(result, "make() should succeed");

    // Verify expand was called
    assert!(
        EXPAND_WAS_CALLED.load(Ordering::SeqCst),
        "expand() should have been called on the GRootNode during make()"
    );

    // Verify the generated nodes were added to the graph
    // We expect: 1 root + 2 generated = 3 nodes
    let final_node_count = g.g.node_count();
    assert_eq!(
        final_node_count, 3,
        "Should have 3 nodes after make (1 root + 2 generated), but got {}",
        final_node_count
    );
}
